# http4s Services and Routing

## Goals 

- Learn how http4s does routing
- Write a route to handle the close event
- Write tests for a route


## Endpoints and Services

We will sometimes use the term *endpoints* to refer to the URLs a server responds to. The web framework we are using on the backend, [http4s], has a concept called *services*, which is a collection of related endpoints.

Take a look at the file `ToDoneService.scala`, which defines the endpoints for the ToDone service---the main service we will be working on. You'll see a line like

```scala
case GET -> Root / "api" / "tasks" => // stuff here
```

This defines a *route*. Let's learn about them.


## Routes

*Routing* is term we use for determining the code that should run given an HTTP request. A *route* is basically another term for an endpoint. http4s provides some functionality for routing. It may look complicated but it works entirely with Scala pattern matching, just in a more elaborate form than you may be used to.

The route 

```scala
case GET -> Root / "api" / "tasks" => // stuff here
```

is looking for an HTTP request with the `GET` method, and a path in the URL that exactly matches `/api/tasks`. If you look in the developer tools network panel you should see a request from the frontend that matches this.

Rather than going over the different patterns the routing library provides, we're going to explain how it works so you can figure it out yourself. You'll want to start by looking at `Path.scala` in the [implementation][dsl]. Specifically, search for `->` within that file. You should find something like

```scala
object -> {

  /** HttpMethod extractor:
    * {{{
    *   (request.method, Path(request.path)) match {
    *     case Method.GET -> Root / "test.json" => ...
    * }}}
    */
  def unapply[F[_]](req: Request[F]): Some[(Method, Path)] =
    Some((req.method, Path(req.pathInfo)))
}
```

To understand this we need to know two things:

- how Scala use `unapply` methods to allow custom pattern matching
- how Scala works with infix pattern matching.

Let's address these in turn.


### Unapply

In Scala any object with an `unapply` method can be used to implement custom pattern matching. Such objects are known as *extractor objects*. 

The `unapply` method must take a value of the type being matching and return an `Option` of the possible values it breaks the input into (returning `None` if the pattern did not match anything). In the case of `->` the method signature `def unapply[F[_]](req: Request[F]): Some[(Method, Path)]` tell us that:

- `->` will match a `Request`;
- it will break a `Request` into two components, a `Method` and a `Path`; and
- the match cannot fail because the result type is `Some` instead of the more general `Option`.

When we look at our example match

```scala
case GET -> Root / "api" / "tasks" => // stuff here
```

we see that `->` is being used in exactly this way: on the left we have a `Method` and on the right `Path`. The unusual thing is that `->` is being used as an infix pattern match. We will learn about that in just a moment.

One final thing before we move on. Some patterns break their input into a variable number of components. These are implemented with a method called `unapplySeq` instead of `unapply`. You'll find one in `Path`.


### Infix Patterns

Scala, for better or worse, allows infix patterns. Where we'd usually write `Example(a, b)` we can instead write `a Example b`. If the pattern has more than two components in its output we'd write `a Example (b, c, d)`. It's a simple rule but you don't see it very often so it can be confusing the first time you encounter it.


### Case Classes

Just remember that case classes automatically support pattern matching---which we now know is an `unapply` method on the companion object. This is generated by Scala for us.


### Putting it Together

Let's return to our example route

```scala
case GET -> Root / "api" / "tasks" => // stuff here
```

We already know how the `->` pattern works. Now let's pull apart the path pattern (the bit on the right of `->`). If you look through the [implementation][dsl] you will find a case object called `Root` and a case class called `/`. So `Root / "api" / "tasks"` is constructing a pattern that matches the compound object (through the combined power of infix patterns and case class patterns).

```scala
/(/(Root, "api"), "tasks")
```

This is an unusually complex application of pattern matching, but it's not magic.


## http4s Route Syntax

[http4s]: https://http4s.org/
[dsl]: https://github.com/http4s/http4s/tree/main/dsl/src/main/scala/org/http4s/dsl/impl
